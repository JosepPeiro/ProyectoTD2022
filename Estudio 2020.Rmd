---
title: "Estudio datos 2020"
author: "Gema Bravo, Josep Peiro, Candela Santandreu, Mireia Risueño & Javier Montaner"
date: "16/4/2022"
output: 
  html_document:
    toc: true 
    toc_float:
      collapsed: true
      smooth_scroll: true
---

<style>
#TOC {
  color: #708090;
  font-family: Calibri;
  font-size: 16px; 
  border-color: #708091;
}
h1.title {
  color: #F08080;
  background-color: #F5F5F5;
  font-family: Calibri;
}
h4.author{
  color: #708090;
  font-family: Calibri;
}
h4.date{
  color: #708090;
  font-family: Calibri;
  font-size: 16px;
  background-color: #F5F5F5;
}
body {
  color: #708090;
  font-family: Calibri;
  background-color: #F5F5F5;
}
pre {
  color: #708090;
  background-color: #F8F8FF;
}
</style>

```{r setup, cache = F, echo = F, message = F, warning = F, tidy = F}

# CONFIGURACIÓN GENERAL
library(knitr)
options(width = 100)

# Opciones generales de los chucks. Se utilizarán salvo cambios en el chunk
opts_chunk$set(echo=T, message = F, error = F, warning = F, comment = NA, fig.align = 'center', dpi = 200, tidy = F, cache.path = '.cache/', fig.path = './figura/')

# Opciones generales de dígitos cuando se incluyen tablas
#options(xtable.type = 'html')
knit_hooks$set(inline = function(x) {
  
  if(is.numeric(x)) {
    round(x, getOption('digits'))
  } else {
    paste(as.character(x), collapse = ', ')
  }
})
#knit_hooks$set(plot = knitr:::hook_plot_html)
```

```{r, echo=F}
# Especificamos las librerías necesarias en esta lista

packages = c("readr","dplyr","lubridate", "tidyr","tibble", "ggplot2", "purrr", "PerformanceAnalytics", "grid", "ggridges", "forcats", "GGally")

#use this function to check if each package is on the local machine
#if a package is installed, it will be loaded
#if any are not, the missing package(s) will be installed and loaded
package.check <- lapply(packages, FUN = function(x) {
  if (!require(x, character.only = TRUE)) {
    install.packages(x, dependencies = TRUE,repos='http://cran.rediris.es')
  }
  library(x, character.only = TRUE)
})

#verify they are loaded
#search()

```
# Trabajo 2020
Este sera el Rmd donde trabajaremos con los datos de 2020

## Carga de datos
```{r}
load("./dataframes/datos_2020.Rdata")
datos = datos_2020
```

## Estudio estadistico

Lo primero que hacemos es calcular los valores estadísticos como la media, mediana, percentil...
```{r}
estadisticos = function(x){
  minimo = round(min(x, na.rm=T),2)
  percentil_25 = round(quantile(x, 0.25, na.rm=T),2)
  mediana = round(median(x, na.rm=T),2)
  media = round(mean(x, na.rm=T),2)
  desviacion_tipica = round(sd(x, na.rm=T),2)
  percentil_75 = round(quantile(x, 0.75, na.rm=T),2)
  maximo = round(max(x, na.rm=T),2)
  vector = c(minimo, percentil_25, mediana, media, desviacion_tipica, percentil_75, maximo)
  names(vector)=NULL
  return (vector)
}
```

Una vez los tenemos calculados y almacenados, los mostramos en una tabla , donde cambiamos los nombres para que quede todo mas claro
```{r}
tabla_estadisticos = data.frame()

for (a in datos[,2:6]){
  b = estadisticos(a)
  tabla_estadisticos=rbind(tabla_estadisticos, b)
}

colnames(tabla_estadisticos) = c("minimo", "percentil_25", "mediana", "media", "desviacion_tipica", "percentil_75", "maximo")
rownames(tabla_estadisticos)=colnames(datos[,2:6])
tabla_estadisticos
```

**Con esta primera tabla ya tenemos un primer analisis de los datos donde se puede ver cual es el ruido maximo, minimo... durante las diferentes partes del día, en todo el dia...** 

## Estudio outliers
```{r}
outliers = function(x, method="3sigma"){
  media = mean(x)
  sigma = sd(x)
  mediana = median(x)
  q1 = quantile(x, 0.25)
  q3 = quantile(x, 0.75)
  iqr = IQR(x)
  if (method == "3sigma"){
    lowLim = media-3*sigma
    upLim = media+3*sigma
  } 
  if(method=="percentil"){
    lowLim=quantile(x, 0.05)
    upLim=quantile(x, 0.95)
  }
  if(method=="boxplot"){
    lowLim=q1-1.5*iqr
    upLim=q3+1.5*iqr
  }
  if (method == "hampel"){
    medabdev = mad(x)
    lowLim=mediana-3*medabdev
    upLim=mediana+3*medabdev
  }
  nOut = length(which(x<lowLim|x>upLim))
  minIn = min(x[which(x>lowLim)])
  maxOut = max(x[which(x<lowLim)])
  maxIn = max(x[which(x<upLim)])
  minOut = min(x[which(x>upLim)])
  resultado = cbind(nOut, lowLim, upLim, maxOut, minIn, maxIn, minOut)
  rownames(resultado)=NULL
  return (resultado)
}
```


```{r}
out_3sigma = data.frame()
for (c in datos[,2:6]){
  resultado = outliers(c)
  out_3sigma=rbind(out_3sigma, resultado)
}
out_3sigma

out_percentil = data.frame()
for (c in datos[,2:6]){
  resultado = outliers(c, "percentil")
  out_percentil=rbind(out_percentil, resultado)
}
out_percentil

out_boxplot = data.frame()
for (c in datos[,2:6]){
  resultado = outliers(c, "boxplot")
  out_boxplot=rbind(out_boxplot, resultado)
}
out_boxplot

out_hampel = data.frame()
for (c in datos[,2:6]){
  resultado = outliers(c, "hampel")
  out_hampel=rbind(out_hampel, resultado)
}
out_hampel
```

## Estudio correlación y covarianza
Calculamos la correlacion y covarianza para ver la similitud de la produccion de sonido dependindon del momento del dia
```{r}

cat('Covarianza Pearson\n')
cov(select(datos,starts_with("noise")))
cat('\nCorrelación Pearson\n')
cor(select(datos,starts_with("noise")))
cat('\nCovarianza Spearman\n')
cov(select(datos,starts_with("noise")),method = 'spearman')
cat('\nCorrelación Spearman\n')
cor(select(datos,starts_with("noise")),method = 'spearman')

GGally::ggpairs(select(datos,starts_with("noise")))
chart.Correlation(select(datos,starts_with("noise")))
```
Ponemos los datos tidy en ordden de cuando fueran tomadas las muestras y agrupadas por calles
```{r}
datos_tidy = datos %>% select(-year) %>% gather("noise", "value", 2:6) %>% separate(noise, into=c("noise_column", "noise"), sep="_") %>% select(-noise_column) %>% mutate(noise=as.factor(noise), Street=as.factor(Street))
head(datos_tidy)
```

```{r}
library(grid)

multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}
```


Comparamos la cantidad de sonido con el momento del dia
```{r}
gd1 = ggplot(datos_tidy, aes(noise, value, fill=noise))+geom_violin()+theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position="none")
gd2 = ggplot(datos_tidy, aes(noise, value, color=noise))+geom_boxplot()+theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position="none")

multiplot(gd1, gd2, cols=2)
```
Contamos la cantidad de veces que se repite una frecuencia en diferentes momentos del dia
```{r}
gh1=ggplot(datos_tidy, aes(value))+geom_histogram(binwidth=1)+facet_wrap(~noise, nrow=5)
gh2=ggplot(datos_tidy, aes(value,fill=noise))+geom_density(alpha=0.5)+facet_wrap(~noise, nrow=5)+theme(legend.position = "none")
gh3=ggplot(datos_tidy, aes(value,fct_rev(noise),fill=noise))+geom_density_ridges(alpha=0.5)+theme(legend.position = "none")
layout <- matrix(c(1,2,1,2,3,3),3,2,byrow=TRUE)

multiplot(gh1, gh2,gh3, layout=layout)
```
Comparaacion del valor del sonido con cada una de las calles
```{r}
gdb=ggplot(datos_tidy, aes(x=Street, y=value, fill=Street)) + 
    geom_boxplot() + theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position="none")+
    scale_x_discrete(breaks=NULL)

gdv=ggplot(datos_tidy, aes(x = Street, y = value)) + 
  geom_jitter(size = 1, color = 'gray', alpha = 0.5) +
  geom_violin(aes(fill = Street), color = 'black', alpha = 0.8) + 
  theme_minimal()+ theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position="top", legend.title=element_blank())+
  scale_x_discrete(breaks=NULL)

#Eliminar esto
# leg=ggplot(datos_tidy, aes(x = Street, y = value))+
#     geom_violin(aes(fill = Street), color = 'black', alpha = 0.8) +
#     theme(panel.background=element_blank(), 
#           axis.text.x=element_blank(), 
#           axis.text.y=element_blank(),
#           axis.ticks.x=element_blank(),
#           axis.ticks.y=element_blank())
multiplot(gdb, gdv, layout=matrix(c(1,1,2,2,2,2),3,2, byrow=T))
```
Comparacion del sonido en diferentes momentos del dia en cada calle
```{r}
ggplot(datos_tidy, aes(x = dateObserved, y = value, color=noise, alpha=noise)) +
  geom_line() + facet_wrap(~Street, nrow=4)
```

#### Pequeño problemo
Como si los hacemos por juntos queda feisimo, vamos a probar a hacerlos todos por separado

```{r, echo=FALSE, fig.align='center', out.width="70%"}
ggplot(datos_tidy %>% filter(noise=="morning"), aes(x = dateObserved, y = value)) +
  geom_line() + facet_wrap(~Street, nrow=4)
ggplot(datos_tidy %>% filter(noise=="afternoon"), aes(x = dateObserved, y = value)) +
  geom_line() + facet_wrap(~Street, nrow=4)
ggplot(datos_tidy %>% filter(noise=="night"), aes(x = dateObserved, y = value)) +
  geom_line() + facet_wrap(~Street, nrow=4)
ggplot(datos_tidy %>% filter(noise=="all"), aes(x = dateObserved, y = value)) +
  geom_line() + facet_wrap(~Street, nrow=4)
ggplot(datos_tidy %>% filter(noise=="min"), aes(x = dateObserved, y = value)) +
  geom_line() + facet_wrap(~Street, nrow=4)
```
Cantidad de sonido en diferentes momento del dia a lo largo de los meses del año
```{r}
ggplot(datos_tidy, aes(x = dateObserved, y = value, color = noise)) +
  geom_point(size=0.5, shape=10)+geom_smooth(method="lm")

ggplot(datos_tidy, aes(x = dateObserved, y = value, color = noise)) +
  geom_point(size=0.5, shape=10)+geom_smooth(method=lm)
```
Cantidad de sonido en diferentes momento del dia a lo largo de los meses del año en cada calle
```{r}
ggplot(datos_tidy, aes(x = dateObserved, y = value, color = noise)) +
  geom_point(size=0.5, shape=10)+geom_smooth()+facet_wrap(~Street)
```

```{r}
ggplot(data = datos_tidy, aes(x = dateObserved, y = value, color = noise)) +  
    guides(colour = guide_legend(override.aes = list(size=10))) +
    geom_smooth(alpha = 0.2, size = 0.5, span = 4, se=FALSE) + 
    theme(legend.key = element_rect(fill = "white"))+ facet_wrap(~Street)
```
Media del valor de cada calle
```{r}
ggplot(datos_tidy, aes(x=Street,y=value,fill=Street))+
          geom_bar(stat="identity") + theme(axis.text.x = element_text(angle = 45, hjust = 1))+scale_y_continuous(breaks = seq(0, 35000, 2500))+theme(legend.position="none")

ggplot(datos_tidy, aes(x=Street,y=mean(value),fill=Street))+
          geom_bar(stat="identity") + theme(axis.text.x = element_text(angle = 45, hjust = 1))+scale_y_continuous(breaks = seq(0, 35000, 2500))+theme(legend.position="none")
```

```{r, message=FALSE}
datos_estadisticos = datos_tidy %>% group_by(Street) %>% summarise(long, mean_val=mean(value), median_val=median(value), max_val=max(value), min_val=min(value)) %>% ungroup()

lv1=datos_estadisticos %>% ggplot(aes(long, mean_val))+geom_point()+scale_y_continuous(limits = c(55,65))+ theme(axis.text.x = element_text(angle = 90, hjust = 1))
lv2=datos_estadisticos %>% ggplot(aes(long, median_val))+geom_point()+scale_y_continuous(limits = c(55,65))+ theme(axis.text.x = element_text(angle = 90, hjust = 1))

layout=matrix(c(1,1,2,2), 2,2)
#multiplot(lv1, lv2, layout=layout)

lv3=datos_estadisticos %>% ggplot(aes(long, max_val))+geom_point()+ theme(axis.text.x = element_text(angle = 90, hjust = 1))
lv4=datos_estadisticos %>% ggplot(aes(long, min_val))+geom_point()+ theme(axis.text.x = element_text(angle = 90, hjust = 1))

#multiplot(lv3, lv4, layout=layout)

lvtt=ggplot(datos_tidy, aes(long, value, color=Street))+geom_jitter()+scale_y_continuous()+theme(legend.position = "bottom", legend.text = element_text (size = 4.5), legend.title = element_blank(), legend.key.size = unit(0.2, "cm"), legend.key=element_rect(color=NA))+labs(x="Longitud calles")

layout=matrix(c(1,3,2,4,5,5,5,5),2,4)
multiplot(lv1, lv2, lv3, lv4, lvtt, layout=layout)
```
Covarianza y correlacion de la media de los datos estaditicos
```{r}
datos_tidy %>% mutate(level=case_when(
  between(value, 10, 30) ~ "Very Low", 
    between(value, 30, 50) ~ "Low", 
    between(value, 50, 65) ~ "Medium", 
    between(value, 65, 80) ~ "Loud", 
    TRUE ~ "Very Loud"
)) %>% ggplot(aes(noise, fill=level))+geom_bar(position="dodge")
```

```{r}
cov(datos_estadisticos$long, datos_estadisticos %>% select(ends_with("val")))
cor(datos_estadisticos$long, datos_estadisticos %>% select(ends_with("val")))
cov(datos_estadisticos$long, datos_estadisticos %>% select(ends_with("val")),method = 'spearman')
cor(datos_estadisticos$long, datos_estadisticos %>% select(ends_with("val")),method = 'spearman')
```

```{r}
cov(datos_tidy$long, datos_tidy$value)
cor(datos_tidy$long, datos_tidy$value)
cov(datos_tidy$long, datos_tidy$value,method = 'spearman')
cor(datos_tidy$long, datos_tidy$value,method = 'spearman')
```

##Preguntas 2020
A traves de los datos obtenidos en el analisis previo podemos plantear unas preguntas las cuales se van a poder responder con estos mismos datos.

Las preguntas relacionadas con el año 2020 son las siguientes:
- ¿Durante que parte del dia ha sido minimo y maximo el ruido?
- ¿Cual ha sido el mínimo y máximo de ruido registrado?
- ¿Cuales son los momentos del dia que mas semejante es el ruido?
- ¿En que calle se solia escuchar mas y menos ruido?
- ¿En las calles con mas y menos ruido durante que momento del dia se han producido estos picos?
- ¿En que epoca del año hay ayor produccion de ruido?
- ¿Que calle tiene una media del sonido mas alta?
- ¿Tiene que ver algo la largaria de las calles con su sonido?

